\section{Introduction}

Dijkstra viewed programming as the process of the ``refinement of specification.'' This applies not only to imperative programming, but in the myriad fields of Artificial Intelligence Research. It is especially made clear given that the levels of refinement we are able to obtain in our various formalisms, programs, etc.\, are inherently tied to the languages we use to reason about our problem domains.

This is also a central view taken by many members of what has been termed: the ``Knowledge Representation and Reasoning Community.'' Within this community one of the central goals has been to understand and formalize the reasoning of intelligent agents. A number of languages have developed such \emph{action languages}, and the language of \emph{answer set prolog} (denoted throughout as A-Prolog). A rather significant body of work has been done regarding various reasoning tasks such as planning, diagnosis, prediction, counter-factual reasoning, etc., all from the perspective of them being simply one of many reasoning tasks an agent may perform. This has lead to a framework for the design and development of intelligent agents based on a \emph{portfolio} of languages, corresponding roughly to individual levels of refinement about an agent's knowledge of the domain.

This central view does not appear to be shared by the ``Classical Planning'' community, given its use of a single language, \emph{PDDL}, which was ``originally developed by the AIPS-98 Competition Committee for use in defining problem domains.''

This difference in first principles leads to some interesting consequences which we hope to explore to some extent in this paper. The rest of this paper is structured as follows: an overview of the classical planning approach will be given in the context of four different planning domains, The Blocks World, Towers of Hanoi, Lin's Briefcase, and an Electrical Circuit. Once this has been, a similar overview of the knowledge representation and reasoning approaches, including descriptions of the action language $\AL$, followed by the logic programming language of A-Prolog. Once this has been covered, representations of the aforementioned domains will be presented.
